from mirage.core import scenario, interpreter, module
from mirage.libs import io, ble, bt, utils
from mirage.libs.ble_utils.firewall import *
import configparser,os.path,subprocess

class mitm_test(scenario.Scenario):

    def onStart(self):
        self.a2sEmitter = self.module.a2sEmitter
        self.a2sReceiver = self.module.a2sReceiver
        self.a2mEmitter = self.module.a2mEmitter
        self.a2mReceiver = self.module.a2mReceiver
        self.firewallManager = FirewallEventManager()
        self.dependencies = ["ble_discover"] # for GATT
        io.info("MITM started !")
        return True
    
    def onEnd(self):
        io.info("MITM finished")
        return True

    {% for handler in properRules %}
    def {{handler}}(self,packet):
        #Defines what apprend exactly
        currentEvent = self.getEventName(packet.handle, packet.value, self.{{handler}}.__name__)
        #Init counter of the number of packets if it's the first time that packet is handled 
        self.firewallManager.initCounters(currentEvent)
        #Computes duration in seconds where last time where packet comes, 0 is default value
        sinceLastEventDuration = self.firewallManager.durationSinceLastPacket(currentEvent){% for rule in properRules[handler] %}
        if packet.handle == {{rule.handle}} and {{rule.value}} in packet.value:
            #Increment counter of one packet and update timestamp of last packet that comes
            self.firewallManager.countEvent(currentEvent){% if rule.number > 0 and rule.action == False  %}
            #Check if flow of packets is allowed or not
            if self.firewallManager.getCurrentCount(currentEvent) >= {{rule.number}} and sinceLastEventDuration < WINDOW_SIZE_IN_SECONDS:
                return self.__drop(currentEvent)
            elif sinceLastEventDuration > WINDOW_SIZE_IN_SECONDS: # After a certain time counters go down
                self.firewallManager.resetCounters(currentEvent)
            else: # number of packet flows is inferior of limit during window
                return True{% else %}
            # packet is allowed
            return True{% endif %}{% endfor %}
        else : #default case of the rule
            return {{'self.__drop(currentEvent)' if not BleTable.default else True}}
{% endfor %}
    # Drop packets and reset counter of packets after drops
    def __drop(self, name: str):
        io.info("According to our firewall policy we choose to drop the packet")
        self.firewallManager.resetCounters(name)
        return False

    def getEventName(self, handle: hex, value: hex, handlerName: str):
        return "{0}_{1}_{2} ".format(str(handle),str(value),handlerName)
    def onSlaveConnect(self, initiatorType="public"):
        # Entering the GATT Entering Cloning mode
        while (self.a2sEmitter.getMode() != "NORMAL"):
            utils.wait(seconds=1)
            print(self.a2sEmitter.getMode())
            
        address = utils.addressArg(self.args["TARGET"])
        connectionType = self.args["CONNECTION_TYPE"]
        self.responderAddress = address
        self.responderAddressType = (b"\x00" if self.args["CONNECTION_TYPE"] == "public" else b"\x01")

        io.info("MITM: Connecting to slave "+address+"...")
        self.a2sEmitter.sendp(ble.BLEConnect(dstAddr=address, type=connectionType, initiatorType=initiatorType))

        while not self.a2sEmitter.isConnected(): utils.wait(seconds=0.5)

        # If conneced correctly, then clone the GATT Server
        if self.a2sEmitter.isConnected():
            io.success("Connected on slave : "+self.a2sReceiver.getCurrentConnection())
            
            io.info("MITM: Cloning GATT Server / ATT Attributes ... ")
            self.__getGattSlave("GATT_SLAVE_MITM", "ATT_SLAVE_MITM")
            io.success("MITM: Cloning has been finished ... ")
            io.info("MITM: GATT/ATT starting server ...")
            self.__setGattServer("GATT_SLAVE_MITM", "ATT_SLAVE_MITM")
            io.success("MITM: GATT/ATT server running ... ")
        else:
            io.fail("MITM: No active connections !") 
        return False